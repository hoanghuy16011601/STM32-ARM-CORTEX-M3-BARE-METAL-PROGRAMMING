/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>
#include "main.h"
#include "STM32F103C8_IRQ.h"
#include "HUY_GPIO.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

typedef struct
{
	volatile uint32_t PSP_Value;
	volatile uint32_t Task_Tick;
	void (*Task_Handler)(void);
	volatile uint8_t Task_State;
}Task_Control_t;

Task_Control_t User_Task[5];

uint32_t Current_Task =0;
uint32_t Global_Tick =0;
uint8_t state_led = LOW;

int main(void)
{
	GPIO_MODE(GPIO_PORTC,13,OUTPUT_50MHZ,OP_GENERAL_PUSH_PULL);
	GPIO_MODE(GPIO_PORTA,11,OUTPUT_50MHZ,OP_GENERAL_PUSH_PULL);
	GPIO_MODE(GPIO_PORTA,12,OUTPUT_50MHZ,OP_GENERAL_PUSH_PULL);
	GPIO_MODE(GPIO_PORTB,5,OUTPUT_50MHZ,OP_GENERAL_PUSH_PULL);
	Init_Scheduler_Stack();
  Task_Init();
  Switch_SP_To_PSP();
	Systick_Timer_Init(1,72000000);
	for(;;);
}

void Task_Init()
{
	//Init Tasks's Stack frame
	User_Task[0].PSP_Value = Idle_STACK_START;
	User_Task[1].PSP_Value = Task1_STACK_START;
	User_Task[2].PSP_Value = Task2_STACK_START;
	User_Task[3].PSP_Value = Task3_STACK_START;
	User_Task[4].PSP_Value = Task4_STACK_START;

	//Init Tasks's State
	User_Task[0].Task_State = Ready_State;
	User_Task[1].Task_State = Ready_State;
	User_Task[2].Task_State = Ready_State;
	User_Task[3].Task_State = Ready_State;
	User_Task[4].Task_State = Ready_State;

	//Init Tasks's Handler

	User_Task[0].Task_Handler = Idle_Handler;
	User_Task[1].Task_Handler = Task1_Handler;
	User_Task[2].Task_Handler = Task2_Handler;
	User_Task[3].Task_Handler = Task3_Handler;
	User_Task[4].Task_Handler = Task4_Handler;

	uint32_t *pPSP;
	for(uint8_t i=0;i<5;i++)
	{
		pPSP = (uint32_t *)User_Task[i].PSP_Value;
		pPSP--;
		*pPSP = 0x01000000; ///xPSR

		pPSP--;
		*pPSP = (uint32_t)User_Task[i].Task_Handler; /// PC

		pPSP--;
		*pPSP = 0xFFFFFFFD; ///LR

		for (uint8_t j = 0;j<13;j++)
		{
			pPSP--;
			*pPSP =0;
		}
		User_Task[i].PSP_Value = (uint32_t)pPSP;

	}

}


__attribute__((naked)) void Switch_SP_To_PSP(void)
{
	//// Coppy Idle's PSP Value to PSP
	__asm volatile ("PUSH {LR}");
	__asm volatile ("BL Get_PSP_Value");
	__asm volatile ("POP {LR}");
	__asm volatile ("MSR PSP,R0");

	//// Switch SP
	__asm volatile ("MOV R0,#0x02");
	__asm volatile ("MSR CONTROL,R0");

	/// EXIT
	__asm volatile ("BX LR");

}

__attribute__ ((naked)) void Init_Scheduler_Stack()
{
	__asm volatile ("PUSH {LR}");
	__asm volatile ("BL Get_Scheduler_Stack");
	__asm volatile ("POP {LR}");
	__asm volatile ("MSR MSP,R0");
	__asm volatile ("BX LR");
}

void Save_PSP_Value(uint32_t Current_SP_Value)
{
	User_Task[Current_Task].PSP_Value = Current_SP_Value;
}

uint32_t Get_PSP_Value()
{
	return User_Task[Current_Task].PSP_Value;
}

uint32_t Get_Scheduler_Stack()
{
	return (uint32_t) Scheduler_STACK_START;
}

void Unblock_Task()
{
	for(uint8_t i =1;i<5;i++)
	{
		if(User_Task[i].Task_State == Blocked_State && User_Task[i].Task_Tick == Global_Tick)
		{
			User_Task[i].Task_State = Ready_State;
		}
	}
}

void Update_NextTask()
{
	uint8_t State = Blocked_State;
	for (uint8_t i=0;i<5;i++)
	{
		Current_Task++;
		Current_Task %=5;
		State = User_Task[Current_Task].Task_State;
		if(Current_Task && State == Ready_State )
		{
			break;
		}
	}
	if (State == Blocked_State)
	{
		Current_Task =0;
	}
}


void SysTick_Handler()
{
	Global_Tick++;
	Unblock_Task();
	System_Pending_PENSV();
}

__attribute__ ((naked)) void PendSV_Handler(void)
{
	//Save R4-R11 to Current Task's Stack
	__asm volatile ("MRS R0,PSP"); /// Get Current Running Task's PSP
	__asm volatile ("PUSH {LR}");
	__asm volatile ("STMDB R0!,{R4-R11}"); /// Save R4-R11 to Current Task's Stack and update R0
	__asm volatile ("BL Save_PSP_Value");  /// Save Current Task's PSP Value

	/// Update NextTask
	__asm volatile ("BL Update_NextTask");


	///Retrieve Next Task's Information
	__asm volatile ("BL Get_PSP_Value"); /// Get Next Task's Past PSP Value
	__asm volatile ("LDMIA R0!,{R4-R11}");  /// Using that PSP to Retrive R4-R11 to Register

	/// Save The Next Task's PSP value to SP(PSP)
	__asm volatile ("MSR PSP,R0");

	__asm volatile ("POP {LR}");
	/// Exit
	__asm volatile ("BX LR");

}

void Task_Delay(uint32_t Tick_Ms)
{
	Disable_IRQ();
	User_Task[Current_Task].Task_Tick += Tick_Ms;
	User_Task[Current_Task].Task_State = Blocked_State;
	System_Pending_PENSV();
	Enable_IRQ();
}

void Idle_Handler()
{
	while(1);
}

void Task1_Handler()
{
	while(1)
	{
		WRITE_GPIO_PIN(GPIO_PORTC,13,LOW);
		Task_Delay(1000);
		WRITE_GPIO_PIN(GPIO_PORTC,13,HIGH);
		Task_Delay(1000);
	}
}

void Task2_Handler()
{
	while(1)
	{
		
		WRITE_GPIO_PIN(GPIO_PORTA,11,HIGH);
		Task_Delay(2000);
		WRITE_GPIO_PIN(GPIO_PORTA,11,LOW);
		Task_Delay(2000);
	}
}

void Task3_Handler()
{
	while(1)
	{
		WRITE_GPIO_PIN(GPIO_PORTA,12,HIGH);
		Task_Delay(3000);
		WRITE_GPIO_PIN(GPIO_PORTA,12,LOW);
		Task_Delay(3000);
	}
}

void Task4_Handler()
{
	while(1)
	{
		WRITE_GPIO_PIN(GPIO_PORTB,5,HIGH);
		Task_Delay(4000);
		WRITE_GPIO_PIN(GPIO_PORTB,5,LOW);
		Task_Delay(4000);
	}
}
